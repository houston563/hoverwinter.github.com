<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Role Space]]></title>
  <subtitle><![CDATA[Carpela's blog]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.carpela.me/"/>
  <updated>2016-03-02T02:06:06.000Z</updated>
  <id>http://blog.carpela.me/</id>
  
  <author>
    <name><![CDATA[Hover Winter]]></name>
    <email><![CDATA[hoverwinter@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[递归与迭代]]></title>
    <link href="http://blog.carpela.me/2016/02/29/recursion-and-iteration/"/>
    <id>http://blog.carpela.me/2016/02/29/recursion-and-iteration/</id>
    <published>2016-02-29T15:44:26.000Z</published>
    <updated>2016-03-02T02:06:06.000Z</updated>
    <content type="html"><![CDATA[<!-- TOC -->
<p>递归到迭代的转化是计算机科学中的一个经典问题，本篇文章简单讨论了是否所有递归都可以转化成迭代，给出了递归向迭代转化的基本方法。并介绍了尾递归，它作为一种特殊形式的递归，许多编译器将其优化为迭代。</p>
<a id="more"></a>
<h2 id="u9012_u5F52_u4E0E_u8FED_u4EE3"><a href="#u9012_u5F52_u4E0E_u8FED_u4EE3" class="headerlink" title="递归与迭代"></a>递归与迭代</h2><p>这个词汇大家都不会陌生，简单来说，递归就是函数自己调用自己，同时需要一个结束条件。上一篇关于约瑟夫问题的博客中就用到了(scheme)：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">josephus</span> n)</span></span><br><span class="line">	<span class="list">(<span class="keyword">cond</span> <span class="list">(<span class="list">(<span class="keyword">=</span> n <span class="number">1</span>)</span> <span class="number">1</span>)</span></span><br><span class="line">    	<span class="list">(<span class="list">(<span class="keyword">=</span> <span class="list">(<span class="keyword">remainder</span> n <span class="number">2</span>)</span> <span class="number">0</span>)</span></span><br><span class="line">        	<span class="list">(<span class="keyword">-</span> <span class="list">(<span class="keyword">*</span> <span class="number">2</span> <span class="list">(<span class="keyword">josephus</span> <span class="list">(<span class="keyword">/</span> n <span class="number">2</span>)</span>)</span>)</span> <span class="number">1</span>)</span>)</span></span><br><span class="line">    	<span class="list">(<span class="keyword">t</span> <span class="list">(<span class="keyword">+</span> <span class="list">(<span class="keyword">*</span> <span class="number">2</span> <span class="list">(<span class="keyword">josephus</span> <span class="list">(<span class="keyword">/</span> <span class="list">(<span class="keyword">-</span> n <span class="number">1</span>)</span> <span class="number">2</span>)</span>)</span>)</span> <span class="number">1</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>再比如经典的Fibonacci数列：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">fib</span> n)</span></span><br><span class="line">	<span class="list">(<span class="keyword">cond</span> <span class="list">(<span class="list">(<span class="keyword">=</span> n <span class="number">1</span>)</span> <span class="number">1</span>)</span></span><br><span class="line">		<span class="list">(<span class="list">(<span class="keyword">=</span> n <span class="number">2</span>)</span> <span class="number">1</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">t</span> <span class="list">(<span class="keyword">+</span> <span class="list">(<span class="keyword">fib</span> <span class="list">(<span class="keyword">-</span> n <span class="number">1</span>)</span>)</span> <span class="list">(<span class="keyword">fib</span> <span class="list">(<span class="keyword">-</span> n <span class="number">2</span>)</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>还有大家所熟知的二叉树遍历。</p>
<p>而迭代通常是大家所熟知的循环结构，它的内存消耗小，执行速度比递归快。所以讨论是否所有递归都可以以及如何转化成迭代是一个热门的话题。</p>
<p>从编译器的角度来看，实际上递归的文法是正则文法，而迭代的文法是上下文无关文法，后者的表达能力较强。迭代和递归的相互转换涉及到图灵完备性问题，即你要用迭代来代替递归的话有时必须要手工维护一个递归数据结构。处理上下文无关文法的下推自动机就是比处理正则文法的有限状态自动机多了一个栈，而递归自然将这个数据结构隐藏在了调用栈之中，所以它是一种更高级的抽象手段，相应的效率较低，并且有 stack overflow 的风险。所以，在不使用递归数据结构的情况下，是无法完成这一转化的。</p>
<h2 id="u5C3E_u9012_u5F52"><a href="#u5C3E_u9012_u5F52" class="headerlink" title="尾递归"></a>尾递归</h2><p>如果在程序结束时只有递归调用的话，就是尾递归，它是很容易转换成迭代的。在scheme等lisp语言中，迭代结构正是通过尾递归表示。ECMAScript 6中明确要求尾递归优化，其它语言比如C，Python编译器不一定会做。并不是所有的递归都可以转成尾递归，比如二叉树的遍历。</p>
<p>但是像上面给出的递归例子，只需保存递归时的状态信息，就可以完成转换，注意在迭代条件不满足时返回结果。约瑟夫问题的递归中变化的只有n和求得的值，转换成迭代就是：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">josephus-iter</span> n val)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cond</span> <span class="list">(<span class="list">(<span class="keyword">=</span> n <span class="number">1</span>)</span> val)</span></span><br><span class="line">    <span class="list">(<span class="list">(<span class="keyword">=</span> <span class="list">(<span class="keyword">remainder</span> n <span class="number">2</span>)</span> <span class="number">0</span>)</span> <span class="list">(<span class="keyword">josephus-iter</span> <span class="list">(<span class="keyword">/</span> n <span class="number">2</span>)</span> <span class="list">(<span class="keyword">-</span> <span class="list">(<span class="keyword">*</span> val <span class="number">2</span>)</span> <span class="number">1</span>)</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="keyword">#t</span> <span class="list">(<span class="keyword">josephus-iter</span> <span class="list">(<span class="keyword">/</span> <span class="list">(<span class="keyword">-</span> n <span class="number">1</span>)</span> <span class="number">2</span>)</span> <span class="list">(<span class="keyword">+</span> <span class="list">(<span class="keyword">*</span> val <span class="number">2</span>)</span> <span class="number">1</span>)</span>)</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">josephus</span> n)</span></span><br><span class="line">  <span class="list">(<span class="keyword">josephus-iter</span> n <span class="number">1</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>而Fibonacci数列需要维持的是n，以及当前迭代次数cur，fib(n-1)和fib(n-2)的值：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; val1: fib(n-2) val2:fib(n-1)</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">fib-iter</span> cur val1 val2 n)</span></span><br><span class="line">	<span class="list">(<span class="keyword">cond</span></span><br><span class="line">		<span class="list">(<span class="list">(<span class="keyword">=</span> n <span class="number">1</span>)</span> <span class="number">1</span>)</span></span><br><span class="line">		<span class="list">(<span class="list">(<span class="keyword">=</span> n <span class="number">2</span>)</span> <span class="number">1</span>)</span></span><br><span class="line">		<span class="list">(<span class="list">(<span class="keyword">=</span> cur n)</span> <span class="list">(<span class="keyword">+</span> val1 val2)</span>)</span></span><br><span class="line">		<span class="list">(<span class="keyword">#t</span> <span class="list">(<span class="keyword">fib-iter</span> <span class="list">(<span class="keyword">+</span> cur <span class="number">1</span>)</span> val2 <span class="list">(<span class="keyword">+</span> val1 val2)</span> n)</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">fib</span> n)</span></span><br><span class="line">	<span class="list">(<span class="keyword">fib-iter</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> n)</span>)</span></span><br></pre></td></tr></table></figure>
<p>使用柯里化(Currying，将多参数的函数转换成单参数函数)的描述如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; currying</span></span><br><span class="line"><span class="list">(<span class="keyword">define</span> <span class="list">(<span class="keyword">currying</span> fn cur val1 val2)</span></span><br><span class="line">	<span class="list">(<span class="keyword">lambda</span> <span class="list">(<span class="keyword">n</span>)</span> <span class="list">(<span class="keyword">fn</span> cur val1 val2 n)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="list">(<span class="keyword">currying</span> fib-iter <span class="number">3</span> <span class="number">1</span> <span class="number">1</span>)</span> <span class="number">5</span>)</span></span><br></pre></td></tr></table></figure>
<p>一般递归调用是递推阶段栈帧依次入栈，回归阶段依次出栈。但是尾递归由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录取代外层函数的调用记录就可以了。</p>
<h2 id="u53C2_u8003_u6587_u732E"><a href="#u53C2_u8003_u6587_u732E" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>SICP</li>
<li>Parsing Techniques</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<!-- TOC -->
<p>递归到迭代的转化是计算机科学中的一个经典问题，本篇文章简单讨论了是否所有递归都可以转化成迭代，给出了递归向迭代转化的基本方法。并介绍了尾递归，它作为一种特殊形式的递归，许多编译器将其优化为迭代。</p>]]>
    
    </summary>
    
      <category term="递归" scheme="http://blog.carpela.me/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="计算机科学" scheme="http://blog.carpela.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
      <category term="函数式编程" scheme="http://blog.carpela.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[约瑟夫问题：递归的角度]]></title>
    <link href="http://blog.carpela.me/2016/02/22/josephus-problem-and-recursion/"/>
    <id>http://blog.carpela.me/2016/02/22/josephus-problem-and-recursion/</id>
    <published>2016-02-22T14:01:26.000Z</published>
    <updated>2016-03-01T15:44:08.000Z</updated>
    <content type="html"><![CDATA[<!-- TOC -->
<p>约瑟夫问题(The Josephus Problem)是计算机科学中一个经典问题，编程语言教学中它经常作为练习题。虽然司空见惯，背后却隐藏着玄机。它又如何与进位制转换扯上关系呢？本篇文章从递归的角度来重新解析这个流传近2000年的老问题，并提出一类递推式的快速解法。</p>
<a id="more"></a>
<h2 id="u95EE_u9898_u5B9A_u4E49"><a href="#u95EE_u9898_u5B9A_u4E49" class="headerlink" title="问题定义"></a>问题定义</h2><p>经典的约瑟夫问题定义如下：</p>
<pre><code>有n个人，标号为 1 ~ n，从n开始，每隔一个人死于非命，求幸存者编号J(n)
</code></pre><p>问题很简洁。它的背景是犹太罗马战争时期，有兴趣者移步。举个简单的例子，假如 n = 10，那么：</p>
<ul>
<li>第一轮淘汰：2 4 6 8 10 死于非命，剩下 1 3 5 7 9 开始新的一轮淘汰</li>
<li>第二轮淘汰：3 7 死于非命，剩下 1 5 9 继续</li>
<li>第三轮淘汰：1 9 死于非命，剩下 5 </li>
<li>Game over</li>
</ul>
<p>可以发现，每一轮淘汰后（n个人），下一轮实际参与人只有 n/2。它的结果是和 J(n/2) 是同一个人，仅仅标号不同而已，而标号之间存在对应关系。上面的例子是偶数个人，以奇数个人试一试会有同样的发现。</p>
<h2 id="u95EE_u9898_u6C42_u89E3"><a href="#u95EE_u9898_u6C42_u89E3" class="headerlink" title="问题求解"></a>问题求解</h2><p>这个问题的暴力解法是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *flag;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">// 查找当前元素cur隔一个的活人</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> cur)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// 跳过所有的死人，得到接下来的活人</span></span><br><span class="line">  <span class="keyword">while</span>(!flag[ ++cur % n]);</span><br><span class="line">  <span class="comment">// 跳过得到活人后面的所有死人，得到隔一个的活人</span></span><br><span class="line">  <span class="keyword">while</span>(!flag[ ++cur % n]);</span><br><span class="line">  <span class="keyword">return</span> cur % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please input the number:"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">" %d"</span>, &amp;n);</span><br><span class="line">  flag = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*n);</span><br><span class="line">  <span class="comment">// 初始为活</span></span><br><span class="line">  <span class="built_in">memset</span>(flag, <span class="number">1</span>, n);</span><br><span class="line">  <span class="comment">// 死 n－1 个人</span></span><br><span class="line">  <span class="keyword">int</span> dead, cur = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(dead=<span class="number">0</span>; dead &lt; n ; dead++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = next(cur);</span><br><span class="line">    flag[tmp] = <span class="number">0</span>;</span><br><span class="line">    cur = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(flag);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Alive: %d\n"</span>, cur == <span class="number">0</span>? n:cur);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的思路很简单，使用数组模拟人的死亡，下标为0的元素表示n号对应的人，由于这n个人形成的是环，这样做是可以的。这段代码看注释容易明白。当然还可以使用循环队列来解决问题，这样更直观，但效率相对较低。</p>
<p>这种解法却没有利用到上面提到的规律，进一步发掘那个规律，J(10)第一轮剩下的五个人相当于J(5)重新编号，而且是 </p>
<pre><code>J(10)站在同一位置的编号 = J(5)对应的编号*2 - 1
</code></pre><p>同理 J(5)第一轮剩下的两个人相当于J(2)重新编号：</p>
<pre><code>J(5)站在同一位置的编号 = J(2)对应的编号*2 + 1
</code></pre><p>即存在以下递归关系：</p>
<pre><code>J(1) = 1;
J(2n) = 2J(n) - 1    n≥1;
J(2n+1) = 2J(n) + 1    n≥1;
</code></pre><p>这个递推式按照指数形式缩减n，但是这种形式不便于计算，我们需要找到一种封闭的形式，通常可以看到更多的信息。</p>
<p>这个解答使用 Common Lisp 描述如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"Please input the number: "</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword">setf</span> n <span class="list">(<span class="keyword">read</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword">defun</span> josephus <span class="list">(<span class="keyword">n</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">cond</span> <span class="list">(<span class="list">(<span class="keyword">=</span> n <span class="number">1</span>)</span> <span class="number">1</span>)</span></span><br><span class="line">    <span class="list">(<span class="list">(<span class="keyword">=</span> <span class="list">(<span class="keyword">mod</span> n <span class="number">2</span>)</span> <span class="number">0</span>)</span></span><br><span class="line">        <span class="list">(<span class="keyword">-</span> <span class="list">(<span class="keyword">*</span> <span class="number">2</span> <span class="list">(<span class="keyword">josephus</span> <span class="list">(<span class="keyword">/</span> n <span class="number">2</span>)</span>)</span>)</span> <span class="number">1</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="keyword">t</span> <span class="list">(<span class="keyword">+</span> <span class="list">(<span class="keyword">*</span> <span class="number">2</span> <span class="list">(<span class="keyword">josephus</span> <span class="list">(<span class="keyword">/</span> <span class="list">(<span class="keyword">-</span> n <span class="number">1</span>)</span> <span class="number">2</span>)</span>)</span>)</span> <span class="number">1</span>)</span>)</span>)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword">format</span> <span class="literal">t</span> <span class="string">"Alive: ~A~%"</span> <span class="list">(<span class="keyword">josephus</span> n)</span>)</span></span><br></pre></td></tr></table></figure>
<p>下面这个式子是显而易见的：</p>
<pre><code>J(2n+1) - J(2n) = 2;
</code></pre><p>使用这个递推关系或者上面的程序可以得出下面这张表：</p>
<table>
<thead>
<tr>
<th>n</th>
<th>1</th>
<th>.</th>
<th>2</th>
<th>3</th>
<th>.</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>.</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>.</th>
<th>16</th>
</tr>
</thead>
<tbody>
<tr>
<td>J(n)</td>
<td>1</td>
<td>.</td>
<td>1</td>
<td>3</td>
<td>.</td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>7</td>
<td>.</td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>7</td>
<td>9</td>
<td>11</td>
<td>13</td>
<td>15</td>
<td>.</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>尤里卡！按照上面的分组，每一组的J(n)都是从1开始，依次递增2。可以用以下的形式改写上述递推式：</p>
<pre><code>J(2^m + l) = 2l + 1;
</code></pre><p>其中 2^m + l = n，2^m 是不超过n的2的最大次幂，l是余下的数。这个结论使用数学归纳法很容易证明。有了这个式子，无需递归就可以线性时间解决这个问题。</p>
<h2 id="u9012_u63A8_u5F0F_u4E0E_u8FDB_u4F4D_u5236"><a href="#u9012_u63A8_u5F0F_u4E0E_u8FDB_u4F4D_u5236" class="headerlink" title="递推式与进位制"></a>递推式与进位制</h2><p>上述递推式涉及到2的次幂，很容易联想到二进制。如果令：</p>
<pre><code>n (radix 10) = AmAm-1...A0 (radix 2)
n = Am * 2^m + Am-1 * 2^m-1 + ... + A0
</code></pre><p>那么：</p>
<pre><code>Am = 1
l = Am-1 * 2^m-1 + ... + A0

J(n) = 2*(Am-1 * 2^m-1 + ... + A0) + 1
     = Am-1 * 2^m + ... + A0 * 2 + 1
     = Am-1Am-2...A0Am (radix 2)
</code></pre><p>好了，一个很明显的规律浮现了：</p>
<pre><code>J(n) = n对应二进制数循环左移一位
</code></pre><p>验证一下：</p>
<pre><code>J(10) = J(1010 (radix 2)) = 101 (radix 2) = 5
J(15) = J(1111 (radix 2)) = 1111 (radix 2) = 15
</code></pre><p>好了，虽然同为线性时间，但这个解比上一个解更加简洁，效率稍微高一点。</p>
<h2 id="u95EE_u9898_u63A8_u5E7F"><a href="#u95EE_u9898_u63A8_u5E7F" class="headerlink" title="问题推广"></a>问题推广</h2><p>上述问题描述的是每两个人有一个人死于非命，推广成一般情形：每隔a个人有一个人死于非命。那么上述递推式的形式转换成：</p>
<pre><code>J(1) = a
J(2) = b
...
J(n-1) = c

J(an) = a * J(n) + x
...
J(an + (a-1)) = a * J(n) + z
</code></pre><p>我们猜测J(n)与a进制有对应的关系。将n表示为n进制数：</p>
<pre><code>n = Am * a^m + ... + A1 * a + A0
</code></pre><ul>
<li>n / a 以后余数 A0，使用 J(an+A0) 与 J(n) 关系的递推式。</li>
<li>n / a / a 以后余数 A1，使用 J(an+A1) 与 J(n) 关系的递推式。</li>
<li>依次类推…</li>
<li>n / a^m 以后，只剩下余数l，这时递推式结束，结果是 J(l) 对应的值。</li>
</ul>
<p>上述过程需要好好理解。重新整理上述过程，将它们联系起来，可以发现：</p>
<pre><code>J(an+A0) 与 J(n) 关系的递推式常量值需乘以 3^0，J(an+A1) 与 J(n) 关系的递推式常量值需乘以 3^1，...，J(an+Am-1) 与 J(n) 关系的递推式常量值需乘以 3^m-1，J(l)需乘以 3^m。
</code></pre><p>也就是说，除了最高位，其它位都是选择递推式的常量值，最高位选择初始值。然后相加即为结果。</p>
<p>描述太过抽象，举个简单的例子：</p>
<pre><code>J(1) = 4
J(2) = 8
J(3n) = 3J(n) - 1
J(3n+1) = 3J(n) + 4
J(3n+2) = 3J(n) + 5
求J(101)
</code></pre><p>使用上述结论：</p>
<pre><code>J(101) = J(10202 (radix 3)) = 4*3^4 - 1*3^3 + 5*3^2 -1*3^1 + 5 = 344
</code></pre><p>验证一下：</p>
<pre><code>J(101) = J(3*33+2) 
        = 3*J(33) + 5 
        = 3*J(3*11) + 5 
        = 3*(3*J(11) - 1) + 5 
        = 3*(3*J(3*3+2) - 1) + 5 
        = 3*(3*(3*J(3)+5) - 1) + 5 
        = 3*(3*(3*(3*J(1) - 1)+5) - 1) + 5 
        = 3*(3*(3*(3*4 - 1)+5) - 1) + 5 
        = 344
</code></pre><p>bingo！好了，此类递归式以后可以很容易求解了。</p>
<h2 id="u91CD_u65B0_u5BA1_u89C6"><a href="#u91CD_u65B0_u5BA1_u89C6" class="headerlink" title="重新审视"></a>重新审视</h2><p>上述一般的规律，实际上就是对递推式求解过程的重新编码，利用进位制转换关系，简化了求解过程。显然利用递归使用原递推式编程实现是很简单的，但效率不高。</p>
<p>一般的规律当然适用于特殊的二进制，但是我们在问题求解中得到的结论却是另一种，我们来重新审视一下：</p>
<pre><code>n = Am*2^m +...+ A0
</code></pre><p>利用上述规律，n展开后，当某一位为0时替换成－1，为1时不变。即：</p>
<pre><code>n对应的二进制 － n按位取反
</code></pre><p>也就是说，<code>n循环左移一位的值</code>和<code>n对应的二进制数</code> － <code>n按位取反后的二进制数</code>是相等的。</p>
<p>拿J(10)验证一下：</p>
<pre><code>1011 - 100 = 111
1010 - 101 = 101
...
</code></pre><p>小小的问题中竟然隐藏着这么多的奥秘！如此简洁的解答体现出数学之美！</p>
<h2 id="u540E_u8BB0"><a href="#u540E_u8BB0" class="headerlink" title="后记"></a>后记</h2><p>本篇文章问题推广以前部分详细描述可见其第一章，受启发于参考文献,问题推广及以后部分为自由发挥，如有问题请指正。</p>
<h2 id="u53C2_u8003_u6587_u732E"><a href="#u53C2_u8003_u6587_u732E" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>Concrete Mathematics: A Fundation for Computer Science<br>  <strong><em>Ronald L. Graham, Donald E. Knuth, Oren Patashnik</em></strong></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<!-- TOC -->
<p>约瑟夫问题(The Josephus Problem)是计算机科学中一个经典问题，编程语言教学中它经常作为练习题。虽然司空见惯，背后却隐藏着玄机。它又如何与进位制转换扯上关系呢？本篇文章从递归的角度来重新解析这个流传近2000年的老问题，并提出一类递推式的快速解法。</p>]]>
    
    </summary>
    
      <category term="约瑟夫问题" scheme="http://blog.carpela.me/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"/>
    
      <category term="递归" scheme="http://blog.carpela.me/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="计算机科学" scheme="http://blog.carpela.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
      <category term="数学之美" scheme="http://blog.carpela.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[博客变迁之路]]></title>
    <link href="http://blog.carpela.me/2016/01/21/about-my-blog/"/>
    <id>http://blog.carpela.me/2016/01/21/about-my-blog/</id>
    <published>2016-01-20T16:11:26.000Z</published>
    <updated>2016-01-20T17:51:56.000Z</updated>
    <content type="html"><![CDATA[<p>早在2014年10月，我就利用Jekyll在Github上搭起了自己的博客，也写不少东西，然而经过数次变故，博文一篇都没留下，其中很大一部分原因是觉得写的博文质量不高。写博客是个好习惯，学习的同时，记录见解，与诸君分享，加深理解。于是乎，用心写作，从头开始，以此文作为博客新的开端。</p>
<a id="more"></a>
<h2 id="v1-0"><a href="#v1-0" class="headerlink" title="v1.0"></a>v1.0</h2><p>我虽不是个Rubyer，但刚接触Jekyll，我便顶着官网的英文文档理解它的原理，同时学习Liquid模版语言的使用。我有一定的Web开发基础，用过别的模板语言，所以这个过程还算顺利。那时做的一个东西用到了Bootstrap，于是乎，博客1.0是在Jekyll-Bootstrap的基础上改出来的，J.B. 没有什么好的主题，我也就被迫写着各种Javascript，HTML，CSS。虽不是专业前端，但要搞一个漂亮的博客，我的那些知识还是够用的。</p>
<p>当时的博客背景是竹子，看起来很清新。左边是用喜欢的英文字体写的个人信息，而且使用JQuery加上触发器的原理搞了一个浮动效果：半透明的圆角矩形框的文章列表下拉超过窗口高度的一半时，信息栏便会滚动到另一个位置固定(JQuery的动画)；拉回页面顶端，信息栏以同样的速度回到原来的位置。每次打开自己的博客我都要来滑几个来回，来当做一种消遣。想想也是无聊。页面的半透明效果和背景真的很搭，整个博客有矩形的地方都弄成圆角。首页文章列表还有隐隐约约的阴影，看起来相当nice。</p>
<p>这个是所有版本里定制程度最高的，有上百次的commit记录，有同学说它很文艺。当时里面就只有四篇关于Linux内核及内核模块网络通信的博客和一篇抒发感情的文章，这几篇文章是用心的写。在用大屏显示器看它之前，我都没想过要换其它主题。一次偶然，发现背景图片在21英尺显示器上有点小，找不到相同的大图，小图拉伸以后不好看。再加上碰到一个主题不错，就换了。</p>
<h2 id="v2-0"><a href="#v2-0" class="headerlink" title="v2.0"></a>v2.0</h2><p>这次使用的是<a href="https://github.com/iHavee/iHavee.github.io" target="_blank" rel="external">iHavee</a>的主题，点击去<a href="http://ihavee.github.io/" target="_blank" rel="external">预览</a>。</p>
<p>在它基础上大致改了一下，修改了分页的位置，模块的位置，首页文章标题下显示的内容等，都是一些小的改动。这个主题总体来说不错，但是有点花哨，当时又在学很多东西，然后博客里面记录了许多算是wiki的东西，只顾着学而没有回头整理，使得博客的内容看起来有点乱。</p>
<p>这个时候想把博客迁到自己在Digital Ocean的VPS上，改用WordPress，但是看着乱乱的内容便没动，最后在VPS上建了个个人主页。</p>
<h2 id="v3-0"><a href="#v3-0" class="headerlink" title="v3.0"></a>v3.0</h2><p>过了一段时间，想打理博客了，找了一个简洁的主题<a href="https://github.com/muan/scribble" target="_blank" rel="external">Scribble</a>，给它加上了Katex支持，通过post页首的yaml属性tex值判断是否开启。然后在这个主题下开了另外一个版块，将所有的post过滤为两部分，一部分是计算机相关，另一部分是生活杂记。这时候发现以前写的文章很多内容都是在别的地方可以找到的，自己的独特思考不多，于是都被删掉了。同时萌生了建一个wiki的想法。</p>
<p>用着用着，发现Katex（包括MathJax）不是太好用，一些数学公式比如有case的无法解析，一篇关于递归问题求解，几种递推公式和进制转换之间联系的博客被搁置，还有一部分原因是在钻研SICP，准备更加深入理解这个问题后再操笔。</p>
<p>当看到有一同学的博客使用这个主题，心里隐隐的有种能换就换的冲动。</p>
<h2 id="v4-0"><a href="#v4-0" class="headerlink" title="v4.0"></a>v4.0</h2><p>在微博大V 网络冷眼的推送中，看到一个程序员写的知识管理的文章，他用 simiki 这个工具来管理那些碎片知识。我立马就把自己的wiki建了起来，放在Github的项目gh-pages分支。</p>
<p>在这之前，看到别人使用 hexo 搭建博客，性能不错，插件很多，主题也比较新，并且一直在更新。看到了一款喜欢的主题：<a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak" target="_blank" rel="external">Tranquilpeak</a> ，于是使用了一年多的Jekyll被抛弃，乘上了hexo的快船。</p>
<p>最终，<a href="http://wiki.carpela.me" target="_blank" rel="external">Wiki</a> 和 <a href="http://blog.carpela.me">Blog</a> 的格局形成。</p>
<p>好好写作吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>早在2014年10月，我就利用Jekyll在Github上搭起了自己的博客，也写不少东西，然而经过数次变故，博文一篇都没留下，其中很大一部分原因是觉得写的博文质量不高。写博客是个好习惯，学习的同时，记录见解，与诸君分享，加深理解。于是乎，用心写作，从头开始，以此文作为博客新的开端。</p>]]>
    
    </summary>
    
      <category term="流水帐" scheme="http://blog.carpela.me/tags/%E6%B5%81%E6%B0%B4%E5%B8%90/"/>
    
      <category term="杂记" scheme="http://blog.carpela.me/categories/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>
